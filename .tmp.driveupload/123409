"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDefaultSettings = exports.getSubscriptionByTenantId = exports.createSubscription = exports.updateUser = exports.getUserById = exports.getUserByPhone = exports.getUserByEmail = exports.createUser = exports.updateTenantQRCode = exports.updateTenantWhatsAppStatus = exports.getActiveTenants = exports.getTenantById = exports.createTenant = void 0;
const uuid_1 = require("uuid");
const supabase_1 = require("../config/supabase");
// Local fallback storage for dev/testing when Supabase is not ready
const localStore = {
    tenants: [],
    users: [],
    subscriptions: [],
    settings: []
};
/**
 * TENANT MANAGEMENT FUNCTIONS
 */
const createTenant = async (data) => {
    console.log('[createTenant] Called for:', data.name);
    const tenant = {
        id: (0, uuid_1.v4)(),
        name: data.name,
        businessType: data.businessType || 'boutique',
        status: 'trial',
        subscriptionTier: 'starter',
        whatsappConnected: false,
        whatsappStatus: 'disconnected',
        createdAt: new Date(),
        updatedAt: new Date()
    };
    if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
        console.log('[createTenant] Attempting Supabase insert...');
        const dbTenant = {
            id: tenant.id,
            name: tenant.name,
            business_type: tenant.businessType,
            status: tenant.status,
            subscription_tier: tenant.subscriptionTier,
            whatsapp_connected: tenant.whatsappConnected,
            whatsapp_status: tenant.whatsappStatus,
            created_at: tenant.createdAt,
            updated_at: tenant.updatedAt
        };
        const { data: inserted, error } = await supabase_1.supabase
            .from('tenants')
            .insert(dbTenant)
            .select()
            .single();
        if (error) {
            console.error('[createTenant] Supabase Error:', error);
            throw new Error(`Database Error (Tenants): ${error.message}`);
        }
        return {
            ...inserted,
            businessType: inserted.business_type,
            subscriptionTier: inserted.subscription_tier,
            whatsappConnected: inserted.whatsapp_connected,
            whatsappStatus: inserted.whatsapp_status,
            createdAt: new Date(inserted.created_at),
            updatedAt: new Date(inserted.updated_at)
        };
    }
    throw new Error('Database connection unavailable (Supabase Disabled).');
};
exports.createTenant = createTenant;
const getTenantById = async (id) => {
    try {
        if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
            const { data, error } = await supabase_1.supabase
                .from('tenants')
                .select('*')
                .eq('id', id)
                .single();
            if (!error && data) {
                return {
                    id: data.id,
                    name: data.name,
                    businessType: data.business_type,
                    status: data.status,
                    subscriptionTier: data.subscription_tier,
                    whatsappConnected: data.whatsapp_connected,
                    whatsappPhoneNumber: data.whatsapp_phone_number,
                    whatsappStatus: data.whatsapp_status,
                    createdAt: new Date(data.created_at),
                    updatedAt: new Date(data.updated_at)
                };
            }
        }
    }
    catch (e) {
        console.error('[getTenantById] Error:', e);
    }
    return null;
};
exports.getTenantById = getTenantById;
const getActiveTenants = async () => {
    try {
        if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
            const { data, error } = await supabase_1.supabase
                .from('tenants')
                .select('*')
                .in('status', ['active', 'trial']);
            if (!error && data) {
                return data.map(d => ({
                    id: d.id,
                    name: d.name,
                    businessType: d.business_type,
                    status: d.status,
                    subscriptionTier: d.subscription_tier,
                    whatsappConnected: d.whatsapp_connected,
                    whatsappPhoneNumber: d.whatsapp_phone_number,
                    whatsappStatus: d.whatsapp_status,
                    createdAt: new Date(d.created_at),
                    updatedAt: new Date(d.updated_at)
                }));
            }
        }
    }
    catch (e) {
        console.error('[getActiveTenants] Error:', e);
    }
    return [];
};
exports.getActiveTenants = getActiveTenants;
const updateTenantWhatsAppStatus = async (tenantId, status, phoneNumber) => {
    try {
        if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
            await supabase_1.supabase
                .from('tenants')
                .update({
                whatsapp_connected: status === 'connected',
                whatsapp_status: status,
                whatsapp_phone_number: phoneNumber,
                updated_at: new Date()
            })
                .eq('id', tenantId);
        }
    }
    catch (e) {
        console.error('[updateTenantWhatsAppStatus] Error:', e);
    }
};
exports.updateTenantWhatsAppStatus = updateTenantWhatsAppStatus;
const updateTenantQRCode = async (tenantId, qrCode) => {
    console.log(`[QR Code] Tenant ${tenantId}: ${qrCode.substring(0, 50)}...`);
};
exports.updateTenantQRCode = updateTenantQRCode;
/**
 * USER MANAGEMENT FUNCTIONS
 */
const createUser = async (data) => {
    console.log('[createUser] Called for:', data.email || data.phone);
    const user = {
        id: (0, uuid_1.v4)(),
        tenantId: data.tenantId,
        email: data.email || undefined,
        phone: data.phone || undefined,
        full_name: data.fullName,
        birth_date: data.birthDate ? new Date(data.birthDate) : undefined,
        passwordHash: data.passwordHash,
        role: data.role || 'owner',
        emailVerified: false,
        phoneVerified: false,
        createdAt: new Date()
    };
    if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
        console.log('[createUser] Attempting Supabase insert...');
        const dbUser = {
            id: user.id,
            tenant_id: user.tenantId,
            email: user.email,
            phone: user.phone,
            full_name: user.full_name,
            birth_date: user.birth_date,
            password_hash: user.passwordHash,
            role: user.role,
            email_verified: user.emailVerified,
            phone_verified: user.phoneVerified,
            created_at: user.createdAt
        };
        const { data: inserted, error } = await supabase_1.supabase
            .from('users')
            .insert(dbUser)
            .select()
            .single();
        if (error) {
            console.error('[createUser] Supabase Error:', error);
            throw new Error(`Database Error (Users): ${error.message}`);
        }
        return {
            ...inserted,
            tenantId: inserted.tenant_id,
            emailVerified: inserted.email_verified,
            phoneVerified: inserted.phone_verified,
            createdAt: new Date(inserted.created_at),
            passwordHash: inserted.password_hash
        };
    }
    throw new Error('Database connection unavailable (Supabase Disabled).');
};
exports.createUser = createUser;
const getUserByEmail = async (email) => {
    try {
        if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
            const { data, error } = await supabase_1.supabase
                .from('users')
                .select('*')
                .eq('email', email)
                .single();
            if (!error && data) {
                return {
                    id: data.id,
                    tenantId: data.tenant_id,
                    email: data.email,
                    phone: data.phone,
                    full_name: data.full_name,
                    birth_date: data.birth_date ? new Date(data.birth_date) : undefined,
                    passwordHash: data.password_hash,
                    role: data.role,
                    emailVerified: data.email_verified,
                    phoneVerified: data.phone_verified,
                    createdAt: new Date(data.created_at)
                };
            }
        }
    }
    catch (e) {
        console.error('[getUserByEmail] Error:', e);
    }
    return null;
};
exports.getUserByEmail = getUserByEmail;
const getUserByPhone = async (phone) => {
    try {
        if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
            const { data, error } = await supabase_1.supabase
                .from('users')
                .select('*')
                .eq('phone', phone)
                .single();
            if (!error && data) {
                return {
                    id: data.id,
                    tenantId: data.tenant_id,
                    email: data.email,
                    phone: data.phone,
                    full_name: data.full_name,
                    birth_date: data.birth_date ? new Date(data.birth_date) : undefined,
                    passwordHash: data.password_hash,
                    role: data.role,
                    emailVerified: data.email_verified,
                    phoneVerified: data.phone_verified,
                    createdAt: new Date(data.created_at)
                };
            }
        }
    }
    catch (e) {
        console.error('[getUserByPhone] Error:', e);
    }
    return null;
};
exports.getUserByPhone = getUserByPhone;
const getUserById = async (id) => {
    try {
        if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
            const { data, error } = await supabase_1.supabase
                .from('users')
                .select('*')
                .eq('id', id)
                .single();
            if (!error && data) {
                return {
                    id: data.id,
                    tenantId: data.tenant_id,
                    email: data.email,
                    phone: data.phone,
                    full_name: data.full_name,
                    birth_date: data.birth_date ? new Date(data.birth_date) : undefined,
                    passwordHash: data.password_hash,
                    role: data.role,
                    emailVerified: data.email_verified,
                    phoneVerified: data.phone_verified,
                    createdAt: new Date(data.created_at)
                };
            }
        }
    }
    catch (e) {
        console.error('[getUserById] Error:', e);
    }
    return null;
};
exports.getUserById = getUserById;
const updateUser = async (id, updates) => {
    try {
        if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
            const { id: _, tenantId: __, ...safeUpdates } = updates;
            // Map updates to snake_case if necessary
            const dbUpdates = { ...safeUpdates };
            if (safeUpdates.emailVerified !== undefined)
                dbUpdates.email_verified = safeUpdates.emailVerified;
            if (safeUpdates.phoneVerified !== undefined)
                dbUpdates.phone_verified = safeUpdates.phoneVerified;
            // Remove camelCase keys
            delete dbUpdates.emailVerified;
            delete dbUpdates.phoneVerified;
            const { data, error } = await supabase_1.supabase
                .from('users')
                .update(dbUpdates)
                .eq('id', id)
                .select()
                .single();
            if (!error && data) {
                return {
                    id: data.id,
                    tenantId: data.tenant_id,
                    email: data.email,
                    phone: data.phone,
                    full_name: data.full_name,
                    birth_date: data.birth_date ? new Date(data.birth_date) : undefined,
                    passwordHash: data.password_hash,
                    role: data.role,
                    emailVerified: data.email_verified,
                    phoneVerified: data.phone_verified,
                    createdAt: new Date(data.created_at)
                };
            }
        }
    }
    catch (e) {
        console.error('[updateUser] Error:', e);
    }
    return null;
};
exports.updateUser = updateUser;
/**
 * SUBSCRIPTION MANAGEMENT FUNCTIONS
 */
const createSubscription = async (data) => {
    const subscription = {
        id: (0, uuid_1.v4)(),
        tenantId: data.tenantId,
        plan: data.plan,
        status: data.status || 'trial',
        startedAt: new Date(),
        expiresAt: data.expiresAt,
        autoRenew: true
    };
    if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
        const dbSub = {
            id: subscription.id,
            tenant_id: subscription.tenantId,
            plan: subscription.plan,
            status: subscription.status,
            started_at: subscription.startedAt,
            expires_at: subscription.expiresAt,
            auto_renew: subscription.autoRenew
        };
        const { data: inserted, error } = await supabase_1.supabase
            .from('subscriptions')
            .insert(dbSub)
            .select()
            .single();
        if (error) {
            console.error('[createSubscription] Supabase Error:', error);
            throw new Error(`Database Error (Sub): ${error.message}`);
        }
        return {
            id: inserted.id,
            tenantId: inserted.tenant_id,
            plan: inserted.plan,
            status: inserted.status,
            startedAt: new Date(inserted.started_at),
            expiresAt: new Date(inserted.expires_at),
            autoRenew: inserted.auto_renew
        };
    }
    throw new Error('Database connection unavailable (Supabase Disabled).');
};
exports.createSubscription = createSubscription;
const getSubscriptionByTenantId = async (tenantId) => {
    try {
        if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
            const { data, error } = await supabase_1.supabase
                .from('subscriptions')
                .select('*')
                .eq('tenant_id', tenantId)
                .order('created_at', { ascending: false })
                .limit(1)
                .single();
            if (!error)
                return data;
        }
    }
    catch (e) {
        console.error('[getSubscriptionByTenantId] Error:', e);
    }
    return null;
};
exports.getSubscriptionByTenantId = getSubscriptionByTenantId;
/**
 * SETTINGS DEFAULT CREATION
 */
const createDefaultSettings = async (tenantId, businessName) => {
    const settings = {
        id: (0, uuid_1.v4)(),
        tenant_id: tenantId,
        bot_name: 'Assistant',
        business_name: businessName,
        business_description: `Bienvenue chez ${businessName}`,
        accepted_payments: JSON.stringify(['cash']),
        delivery_zones: JSON.stringify([]),
        specific_instructions: '',
        created_at: new Date(),
        updated_at: new Date()
    };
    if (supabase_1.isSupabaseEnabled && supabase_1.supabase) {
        const { error } = await supabase_1.supabase
            .from('settings')
            .insert(settings);
        if (error) {
            console.error('[createDefaultSettings] DB Error:', error);
            throw new Error(`Database Error (Settings): ${error.message}`);
        }
        return;
    }
    throw new Error('Database connection unavailable (Supabase Disabled).');
};
exports.createDefaultSettings = createDefaultSettings;
